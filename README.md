# 2023-OS-Project

# REPORT

## TEMP

###git使用指南暂时用

1. 上传：`git add .`;`git commit -m "描述"`;`git push myorigin1 <分支名>`
2. 上传并覆盖：`git push --force myorigin1 <分支名>`
3. 下载并覆盖：`git fetch myorigin1`;`git pull myorigin1 <分支名>`;`git reset --hard myorigin1/<分支名>`
4. 查看分支：`git branch`
5. push from xv6
6. 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

###格式

1. ####实验目的：

2. ####实验步骤：

3. ####实验中遇到的问题与解决方法：

4. ####实验心得：

## Lab: Xv6 and Unix utilities

### Boot xv6 (easy)

1. ####实验目的：

   获取源代码并构建、运行、启动xv6。

2. ####实验步骤：
  
   1. 获取实验室的 xv6 源代码并查看 `util` 分支。运行`$ git clone git://g.csail.mit.edu/xv6-labs-2021`获取代码到本地，并`$ cd xv6-labs-2021`、`$ git checkout util`来查看util分支。
   2. 构建并运行xv6。运行`$ make qemu`。后输入ls运行一个初始文件系统的程序，来查看是否成功构建了xv6。
   3. 退出qemu，可用`Ctrl-a x`。
   
3. ####实验中遇到的问题与解决方法：

   暂无

4. ####实验心得：

   学会了如何启动运行xv6系统，往后的操作都在cd进xv6-labs-2021目录后进行

### sleep (easy)

1. ####实验目的：

   编写程序实现程序“睡眠”，使系统暂停一段时间刻度，这段时间刻度由用户给出。如输入sleep 10指令，系统暂停10个时间刻度。如果用户忘记传递参数，睡眠应打印错误消息。

2. ####实验步骤：

  1. 编写程序。用程序的sleep来实现停顿。程序名为sleep.c

  2. 将sleep.c保存在user文件夹中，并添加sleep到Makefile中的UPROGS下面。（添加一句$U/_sleep\）

  3. 放入后make qemu编译，输入sleep 10，系统暂停了一段时间。![image-20230710225229369](assets/image-20230710225229369.png)

  4. 测试程序。在主系统运行make grade，输入`./grade-lab-util sleep`，运行结果：

     ![image-20230710224443949](assets/image-20230710224443949.png)

     说明程序运行正确。

3. ####实验中遇到的问题与解决方法：

   1. 编写好程序、放入user后仍无法运行，原因是没有make qemu重新编译源代码并生成执行文件，重新编译即可正确运行sleep程序

   2. 测试运行时无法运行指令，需要运行sudo chmod +x ./grade-lab-util，来赋予grade-lab-util可执行权限。

4. ####实验心得：

   1. 头文件：

      1. `#include "kernel/types.h"`: 包含 types.h 头文件，其中定义了一些 xv6 内核中使用的基本数据类型，如 uint、uchar、ushort 等。

      2. `#include "kernel/stat.h"`: 包含 stat.h 头文件，其中定义了用于文件和文件系统的状态信息结构 stat，以及一些与文件操作相关的常量和函数原型。

      3. `#include "user/user.h"`：包含 user.h 头文件，其中定义了一些用户空间程序常用的函数原型，如 fork()、exec()、exit() 等。

   2. `int main(int argc, char* argv[])`：main函数接受两个参数，整数argc表示命令行参数数量，字符指针数组 argv表示命令行参数列表。为了防止调用错误要检查参数数量是否合规（此处为2）。

   3. 输出错误时用到了`fprintf(2, "Usage: sleep times\n")`，2是一个文件描述符，代表标准错误流（stderr），后面是需要输出的错误信息。

   4. `exit(0)`用于退出程序，而不是写return 0。

      

### pingpong (easy)

1. ####实验目的：

   模拟管道的用法。编写程序来“pingpong” 一对管道上的两个进程之间的字节，父进程向子进程发送一个字节; 子进程打印“<pid>：received ping”，<pid> 是其进程 ID， 将管道上的字节写给父进程、退出; 父进程应从子进程读取字节， 打印“<pid>：received pong”、并退出。

2. ####实验步骤：
  
   1. 编写程序。
   2. 用pipe()来创建管道
   3. fork()来创建子进程。
   4. 用read(src,dst,lenth)来读，write(dst,src,lenth)来写。getpid来获取进程id。再将内容打印出来。
   5. 编译。运行结果：![image-20230710235357561](assets/image-20230710235357561.png)
   6. 运行测试程序：![image-20230710234102423](assets/image-20230710234102423.png)
   
3. ####实验中遇到的问题与解决方法：

   暂无

4. ####实验心得：
  
   1. 学会了如何使用管道，以及它是如何在进程间通信、传递信息的。如这里是第一个位置读，第二个位置写。在程序编写时要注意程序读写的前后顺序，且操作完要关闭相应读、写端，以免出现错误。
   2. 对于创建进程的`fork()`语句，系统调用它会创建一个新的进程，新进程是父进程的副本。新进程和原始进程共享相同的代码、数据和打开的文件。在父进程中，fork会返回进程uid，子进程中会返回0，所以在分支语句里会分别执行两个分支。

### primes (moderate)/(hard)

1. ####实验目的：

   使用pipe编写一个素数筛，受限于xv6，范围为2~35。第一个进程将数字2到35输入到管道中，对于每个素数创建一个进程，该进程通过一个管道从其左邻居读取，并通过另一个管道向其右邻居写入。当第一个进程达到35时，进入等待。打印完所有输出、所有其他素数进程退出之后，主进程退出。

2. ####实验步骤：

   1. 阅读Doug McIlroy的`Bell Labs and CSP Threads`文章，理解素数筛的思想

   2. 编写程序。考虑递归的思想，先创建主进程，在主进程中关闭读端，把2~35传进管道，然后关闭管道的写端，并等待子进程的结束。

   3. 对于子进程，编写了create_number_process函数来实现递归，调用它来创建更多的子进程。在每个子进程中，首先从管道中读取一个质数，然后创建一个新的管道。父进程将质数写入新的管道，然后子进程继续从原始管道中读取数字，并将不是质数的数字写入新的管道（还能读到内容，说明一遍还没有处理完成，还需继续写入新管道）。这样，使子进程负责处理不同的质数。

   4. 编译。运行结果：![image-20230711114640768](assets/image-20230711114640768.png)

   5. 运行测试程序：![image-20230711114611851](assets/image-20230711114611851.png)

      

3. ####实验中遇到的问题与解决方法：

   1. 在编写时，有时读写端没有正确关闭，会影响进程间的通信，如：在父进程中写入数据到管道后，如果不关闭写端，子进程无法判断是否已经读取完毕，导致读取阻塞或读取到错误的数据，从而运行报错。为了解决这个问题要在必要的时候正确关闭，如：在各个父进程输入所有数字前关闭读端，输入后关闭写端。
   2. 各个在处理完成后要使用wait(0)进入等待状态，否则会导致子进程没有处理完就退出了，使输出的质数序列不完整。

4. ####实验心得：

   对管道的使用有了更深入的体会，了解了进程同时执行的特征，如在不同进程中打印内容来查看执行情况，可能会出现同时交替输出，体现并发性。

### find (moderate)

1. ####实验目的：

   编写一个简单版本的 UNIX 查找程序，来查找指定目录及其子目录中具有特定名称的所有文件。使用递归允许 find 深入到子目录。

2. ####实验步骤：

   1. 查看user中ls.c文件，来学习读取目录、访问文件的基本方法。ls用于列出指定目录下的文件和文件夹的信息。读出的目录存放在buf变量中，读出的目录项的信息存在struct dirent类型的变量de中，如要获取目录项名称就可以使用de.name。函数还根据文件类型的不同，进行不同的处理：如果是文件类型（T_FILE），则直接输出文件名、类型、节点号和大小；如果是目录类型（T_DIR），则遍历目录中的文件和文件夹，并输出它们的信息。

   2. 编写程序。检查参数，需要输入目录、文件名两个参数。

   3. 编写了用于递归调用的find函数，传入路径和文件名。当访问到目录时，要检查是否是当前目录'.'或者上级目录'..'，如果是则跳过。如果不是就遍历目录，对其中的文件de.name取其名称，并与传入的name比较，如果一样就输出路径。如果当前目录还含有子目录，就递归调用find传入当前路径，在子目录中继续寻找。

   4. 编译。运行结果：      ![image-20230712141756021](assets/image-20230712141756021.png)

   5. 运行测试程序：![image-20230712141938603](assets/image-20230712141938603.png)

      

3. ####实验中遇到的问题与解决方法：

   1. 在使用de.name获取目录项名称、来检查目录是否为'.'或者'..'时出现错误，无法使用strcmp比较得到一致的结果，从而导致递归错误。经过排查后发现是获取的名称可能含有空格，遂在程序中编写了remove_space来去除空格，返回纯文件名，再进行比较。
   2. 如果不过滤上级目录、当前目录，可能导致无限递归等情况，所以要检查当前目录的情况。

4. ####实验心得：

   了解了xv6访问目录、读取文件信息的一般方法，以及可能访问出错的一些情况，如文件打开失败、文件状态获取失败、文件路径太长等情况，对于这些情况要一一给出报错提示。

### xargs (moderate)

1. ####实验目的：

   编写一个简单版本的 UNIX xargs 程序，从管道获取标准输入的读取行内容（出现'\n'前算一行），将这些行作为参数提供给其他命令。

2. ####实验步骤：
  
   1. 理解如何在一个程序中调用其他命令（使用`exec(argv[0], argv);`）
   2. 编写程序。逐行读取内容，读到换行符时将内容存储到新字符串组中，传递给子进程来执行。
   3. 编译。运行结果：![image-20230716004152270](assets/image-20230716004152270.png)
   4. 运行测试程序：![image-20230716004445653](assets/image-20230716004445653.png)
   
3. ####实验中遇到的问题与解决方法：
  
   1. 一开始将执行指令直接写在了父进程中，从标准输入读取完字符直接用`exec(child_argv[0], child_argv);`语句执行了指令，导致报错。原因是在父进程中执行指令会使父进程被阻塞，直到指令执行完成，过程中无法继续读取下一行命令，从而无法实现并发执行多个命令的效果，也会使命令读取参数时出现错误。解决方法是在fork()创建子进程，在父程序中wait等待子进程执行结束。
   
4. ####实验心得：

   了解了xargs指令是如何将参数读取并传递给其他指令的，并对指令的并发执行有了更进一步的理解。

## Lab:system calls

###System call tracing (moderate)

1. ####实验目的：

   为系统编写、添加一个系统调用跟踪功能，创建一个trace系统调用。它采用一个参数，一个整数“掩码”，其位指定要跟踪哪些系统调用。如：要跟踪 fork 系统调用，程序调用`trace(1 << SYS_fork)`，其中`SYS_fork`是来自`kernel/syscall.h`的系统调用号。如果掩码中设置了系统调用的编号，则修改 xv6 内核，以便在每个系统调用即将返回时打印一行，该行应包含进程 ID、系统调用名称和返回值。

2. ####实验步骤：

   1. 将`$U/_trace`添加到 Makefile 中的 UPROGS。该程序检测参数，在参数正确时调用系统的trace函数，实现跟踪。

   2. 在`user/user.h`中添加系统调用的原型。在其system calls下添加：`int trace(int);`

   3. 在`user /usys.pl`中添加调用原型。在其中添加：`entry("trace");`

   4. 在`kernel/syscall.h`中添加系统调用号。添加：`#define SYS_trace  22`

   5. 在`kernel/sysproc.c`中添加`sys_trace()`函数，该函数通过记住`proc`结构中新变量中的掩码参数(mask)来实现跟踪的系统调用。函数如下图所示：

      ![image-20230718225013185](assets/image-20230718225013185.png)

   6. 在`kernel/proc.h`的proc结构体中加入上述变量mask。添加：`int mask;`

   7. 在`kernel/proc.c`中修改fork()函数，使跟踪掩码能从父进程复制到子进程。添加：`np->mask = p->mask;`

   8. 在`kernel/syscall.c`中加入相应的trace项，并在其中添加一个存储系统调用名的数组，以用于打印输出。然后修改其中的syscall函数，使函数检查当前进程的掩码（mask）是否设置了对应系统调用的trace。如果设置了，函数就会打印出该系统调用的名称、进程ID和返回值。

      ![image-20230719195933926](assets/image-20230719195933926.png)

      ![image-20230719200054945](assets/image-20230719200054945.png)

   9. 编译。测试语句`trace 32 grep hello README`，`trace 2147483647 grep hello README` 和`grep hello README`的运行结果如下图所示：![image-20230716210924524](assets/image-20230716210924524.png)

   10. 运行测试语句`trace 2 usertests forkforkfork`，跟踪usertests中forkforkfork测试的所有后代的 fork 系统调用。结果：![image-20230723235700222](assets/image-20230723235700222.png)

3. ####实验中遇到的问题与解决方法：

   1. 一开始编写时将打印进程信息等过程写在user/trace.c中，导致代码较为冗长且输出和运行都发生错误。后将这些操作放在syscall.c中，这样也有利于在后续需要用到系统调用trace时，能够正确打印信息。
   2. 在内核中添加系统调用时需要修改多个文件，为所添加的系统调用提供所需入口，缺失则会导致运行报错。当make qemu报错时根据提示查找是在user中的错误还是在kernel中的错误，并逐一修正。

4. ####实验心得：

   学会如何为系统添加新的系统调用，理解了系统函数在用户态(user)和内核态(kernel)的联系。

###Sysinfo(moderate)

1. ####实验目的：

   实现一个系统调用sysinfo，收集有关正在运行的系统的信息。

   该系统调用采用一个参数：指向struct sysinfo 的指针 。参阅`kernel/sysinfo.h`，如下图所示：

   ![image-20230718203733577](assets/image-20230718203733577.png)

   内核也补充完整此结构体的字段：`freemem`字段应设置为可用内存的字节数，`nproc` 字段应设置为状态 不是UNUSED的进程数

   系统已提供测试程序 `sysinfotest`，如果能够打出"sysinfotest: OK"则说明通过测试。

2. ####实验步骤：

   1. 依据与system call-tracing实验相同的步骤，在内核中加入sysinfo的系统调用。

   2. 在`kernel/sysproc.c`中添加`sys_sysinfo(void)`函数，用于将系统的信息复制到用户空间中，使用的是copyout()方法。函数如下图所示：

      ![image-20230718224547866](assets/image-20230718224547866.png)

   3. 在`kernel/kalloc.c`中添加用于获取空闲可用内存量的`getfreememSize()`函数。函数如下图所示：

      ![image-20230719194425425](assets/image-20230719194425425.png)

   4. 在`kernel/proc.c`中添加用于收集进程数的`proc_getnum()`函数。

      ![image-20230719194647214](assets/image-20230719194647214.png)

   5. 运行测试程序sysinfotest.c，运行结果：![image-20230724000533891](assets/image-20230724000533891.png)

3. ####实验中遇到的问题与解决方法：

   1. 在获取空闲内存、获取进程数时，开始忽略了获取锁、释放锁而使函数独立访问内存的操作，测试程序仍能正常打印出ok而不会报错。然而在实际运行中的多线程、多进程环境中，忽略这样的操作可能会导致数据一致性问题、产生不可预测的结果。如多个线程或进程同时对内存链表进行操作时，可能导致节点的丢失、重复计数或其他不一致的情况，且如果其他进程此时改变了链表，也会导致程序对无效的内存进行操作，从而产生报错。为了防止后续使用这一系统调用时产生这一问题，后续添加了获取、释放锁的操作。使用`acquire(&kmem.lock)`获取锁，`release(&kmem.lock)`释放锁。

4. ####实验心得：

   学习了kalloc.c中的内存数据结构、proc.c中的进程结构，通过它们的成员来获取信息。巩固了系统添加新的系统调用的步骤。

   

##Lab: page tables
###Speed up system calls (easy)

1. ####实验目的：

   优化getpid()系统调用。用户态无法直接读取内核数据，创建一个可读的共享页表项，来使用户态可以直接读取这部分内核数据，跳过系统调用，实现加速。

2. ####实验步骤：
  
   1. 在`kernel/proc.h`中先为proc新建一个字段来存放usyscall的地址。在struct proc结构中添加：struct usyscall *usyscall;
   
   2. 在`kernel/proc.c`的proc_pagetable()中执行映射。参考原有的trapframe的方法，用mappages()注册新的页表项，将USYSCALL映射到上一步新增的`p->usyscall`中。添加：
   
      ![image-20230720201410838](assets/image-20230720201410838.png)
   
   3. 选择允许用户空间仅读取页面的权限位。这在上一步添加映射时有所体现，添加映射时flag 位要置位 PTE_R和PTE_U。置位PTE_U表明用户态有权访问，否则只能 supervisor mode 才能访问。
   
   4. 在`allocproc()`中分配和初始化页面，分配一块物理内存。添加：
   
      ![image-20230720201335088](assets/image-20230720201335088.png)
   
   5. 修改proc_freepagetable，参考已有的trapframe的解映射，在进程释放时对其进行解映射。添加：uvmunmap(pagetable, USYSCALL, 1, 0);
   
   6. 确保在`freeproc()`中释放页面。参考已有的trapframe的释放方式，释放给 usyscall 分配的物理内存（freepagetable中只解映射了页表，并没有释放物理内存，因此需要在此处另外释放）。添加：
   
      ![image-20230720202313671](assets/image-20230720202313671.png)
   
   7. 运行测试程序。
   
      ![image-20230720202442443](assets/image-20230720202442443.png)
   
   8. 回答问题：使用此共享页面可以使其他哪些 xv6 系统调用更快？
   
      1. `read()` 和 `write()`：用于读取和写入文件。如果要读取或写入的文件位于内核空间，使用共享页表可以共享内核的数据，避开系统调用，提高效率。
      2. `memcpy()` ：内存复制，用于将源地址的数据复制到目标地址。如果要复制的数据位于内核空间，则使用共享页表可以避开系统调用而直接读取内容，提高效率。
      3. `strcmp()`：字符串比较，用于比较两个字符串是否相等。如果要比较的字符串位于内核空间，则使用共享页表可以直接读取需要比较的字符，提高效率。
   
3. ####实验中遇到的问题与解决方法：
  
   1. 在运行时出现报错：`pgtbltest: ugetpid_test failed: missmatched PID, pid=6`，查阅资料了解得到此错误为没有将进程号正确赋值，导致期望的进程 ID 与实际进程 ID 不匹配。后在添加映射的程序段前加上`p->usyscall->pid=p->pid`，解决了这一问题。
   
4. ####实验心得：

   学会了内核、用户空间之间共享页表的构建方式，了解了一种加速特定类型系统调用的方法。

###Print a page table (easy)

1. ####实验目的：

   实现可视化 RISC-V 页表，编写一个打印页表内容的函数。

   要求：第一行显示vmprint 的参数。之后，每个页表项都有一行，包括表面的和引用树中更深层次的 PTE。每条 PTE 行都缩进了一些“..”，表示其在树中的深度。每条 PTE 行显示其页表页中的 PTE 索引、pte 位以及从 PTE 中提取的物理地址。不要打印无效的 PTE。在上面的示例中，顶级页表页具有条目 0 和 255 的映射。条目 0 的下一级仅映射索引 0，而该索引 0 的底层具有条目 0、1 和 255。 2 映射。

2. ####实验步骤：

   1. 在`kernel/vm.c`中定义一个vmprint()函数，并在defs.h中声明。采用`pagetable_t`参数，将输出格式设置为上文“要求”中所述的格式。在函数中，采用循环来遍历每个一级页表项及其所有的二三级页表项，获取其地址，如果页表项有效，则按照格式打印出其地址。函数如下图所示：

      ![image-20230721004024382](assets/image-20230721004024382.png)

   2. 在`kernel/exec.c`中的`return argc`之前插入`if(p->pid==1) vmprint(p->pagetable);`，以打印第一个进程的页表。

   3. make qemu编译，系统会打印出页表，如下图所示：

      ![image-20230720233054814](assets/image-20230720233054814.png)

   4. make grade查看pte打印部分的测试，运行结果：![image-20230724004539487](assets/image-20230724004539487.png)

   5. 回答问题：

      1. 第 0 页包含什么内容：在 xv6 中，程序头通常存储在 ELF 文件的第一个页page0中。`kernel/exec.c`文件中有如下图所示的程序段，用于从page0读取ELF文件中的程序头（program header table），并将其中类型为 `ELF_PROG_LOAD` 的段加载到用户进程的地址空间中，这些段通常包含程序的代码段和数据段等信息。

         ![image-20230721011540122](assets/image-20230721011540122.png)

      2. 第 2 页有什么内容：下图为上一段load程序后的程序，分配了两个页, 对应page1和page2。其中page 2 用作用户栈，存储用户进程。

         ![image-20230721012137621](assets/image-20230721012137621.png)

      3. 当运行在用户模式时，进程可以读/写第1页映射的内存吗：进程可以读/写第 1 页映射的内存，因为第 1 页对应的是内核代码和数据的范围。用户进程可以读取其中的常量数据，但不能写入内核空间。

      4. 第三页到最后一页包含了什么：

         

3. ####实验中遇到的问题与解决方法：

   暂无

4. ####实验心得：

   更直观地了解了页表的树结构以及和物理地址的对应，学习了解了特定页的用处与存储的内容。

### Detecting which pages have been accessed (hard)

1. ####实验目的：

   实现`pgaccess()`系统调用，检测哪些页面已被访问。需要三个参数。首先，检查第一个用户页面的起始虚拟地址。其次，检查页数。最后，获取结果存储地址，它将用户地址发送到缓冲区，以将结果存储到位掩码（每页使用一位的数据结构，其中第一页对应于最低有效位）。要求运行pgtbltest时`pgaccess`测试用例通过。

2. ####实验步骤：

   1. 在 `kernel/riscv.h` 中添加宏定义PTE_A，值为6：`#define PTE_A (1L << 6)`

   2. 在`kernel/defs.h`文件中添加定义：`pte_t *  walk(pagetable_t pagetable, uint64 va, int alloc)`。walk函数已在vm.c文件中实现，但未在defs.h文件中定义。它用于在给定页表中查找虚拟地址对应的页表项，并返回指向该页表项的指针，下文需要用到walk来获得连续的PTE。

   3. 在`kernel/sysproc.c`中修改并实现sys_pgaccess()系统调用函数。函数具体实现过程见下图注释。注意在检查PTE_A是否设置后将其置0，否则该位将永远被设置，无法确定自上次调用pgaccess()以来该页面是否被访问过。

      ![image-20230722225320895](assets/image-20230722225320895.png)

   4. 运行测试程序。![image-20230722224312338](assets/image-20230722224312338.png)

3. ####实验中遇到的问题与解决方法：

   1. 对于如何知道哪些页被访问过了：查阅每个PTE的PTE_A位，该位被置1则说明被访问过，该位被置0则说明没被访问过。但是硬件只能置位而无法复位，因此每次调用sys_pgacess检查后要将PTE_A复位为0，从而能够正确表示上次调用pgaccess()以来该页面是否被访问过。

4. ####实验心得：

   熟悉了如何调用一些函数获取参数，学会了如何判断哪些页被访问了。

## Lab: traps

### RISC-V assembly (easy)

1. ####实验目的：

   通过阅读教材相关知识和user中call.c文件编译而成的可读汇编版本，了解汇编语言，回答一系列问题。

2. ####实验步骤：

   1. 编译`user/call.c`文件，生成`user/call.asm`文件。其中与call中的main，printf，f，g函数如下图所示：

      ![image-20230727223913735](assets/image-20230727223913735.png)

      ![image-20230727223935033](assets/image-20230727223935033.png)

      ![image-20230727224014974](assets/image-20230727224014974.png)

   2. **哪些寄存器保留了函数的参数？例如，在main调用printf时，哪个寄存器保留了13？**

      一般来说a0~a7用来存放函数的参数。阅读call.asm可得a2保留了13。

   3. **main的汇编语言中，对函数f的调用在哪里？g的调用在哪里？（提示：编译器可能会内联函数。）**

      可以看到上图main没有任何跳转到f、g的语句。此处是编译器将f内联在了main中，直接计算得到了f(8)的值，同样也将g的语句内联在了f中，提高了运行效率。

   4. **printf的地址在哪里？**

      跳转到printf的指令：jalr  1536(ra) 而在上一句的auipc  ra,0x0中，ra被设置为当前pc的高位，也就是0x30+1536=0x630（备注里也写了，630 <printf>）

   5. **在main中jalr到printf之后，寄存器ra中的值是什么**

      0x34 + 4 = 0x38。0x30行，设置为当前pc高位后，auipc在ra存储返回地址，跳转指令时pc为0x34，将pc+4后赋值给ra，即为0x38。

   6. **运行以下代码：`unsigned int i = 0x00646c72;  printf("H%x Wo%s", 57616, &i);`结果是什么？输出取决于RISC-V是小端对齐。如果RISC-V是大端对齐的，为了得到同样的输出，应该把i设置为什么？是否需要将51676更改为不同的值？**

      新建`user/lab4-test-code.c`并放入代码，加入makefile，输出：

      ![image-20230728162428716](assets/image-20230728162428716.png)

      %x为输出为16进制，57616的16进制为e110。%s为以&i（0x00646c72）为首地址输出字符串，因为RISC-V为小端对齐，所以输出是：0x72，0x6c，0x64，0x00对应的ascii码表中的值（遇到0结尾）。查表得分别对应r，l，d。

      如果是大端对齐，可以设置为0x726c6400，57616不用更改。

   7. **在以下代码:`printf("x=%d y=%d", 3);`中，“y=”后面会打印出什么？（答案不是一个特定的值）。为什么会这样？**

      将`user/lab4-test-code.c`中内容改成上述代码，输出：

      ![image-20230728162515268](assets/image-20230728162515268.png)

      打印出x=3,y=不确定值。因为打印时printf读取了a1，a2的内容，a1传入了3，a2没有传入特定值，所以打出来是不确定的特殊值。

      

3. ####实验中遇到的问题与解决办法：

   暂无

4. ####实验心得：

   对RISC-V的汇编语言有了初步了解。

### Backtrace (moderate)

1. ####实验目的：

   实现回溯的系统调用，打印错误发生点上方函数调用堆栈上的函数调用列表，以便后续调试。

2. ####实验步骤：

   1. 在`kernel/riscv.h`文件中添加文档提供的r_fp()函数，用于获取当前栈帧指针。

   2. 将 backtrace 的原型添加到`kernel/defs.h`中，以便后续在sys_sleep()函数中调用backtrace()

   3. 在`kernel/printf.c`中 实现`backtrace()`函数。注意栈是从高地址向低地址生长，因此栈底元素为栈的页上最高地址，应该用PGROUNDUP(fp)来获取栈底地址。函数如下图所示：

      ![image-20230728222331348](assets/image-20230728222331348.png)

   4. 在`kernel/sysproc.c`的sys_sleep()函数中插入对backtrace的调用，以便在用户层的bttest中测试backtrace()。测试运行截图如下：

      ![image-20230728222633026](assets/image-20230728222633026.png)

3. ####实验中遇到的问题与解决办法：

   在backtrace中使用循环的方式来遍历整个栈的页，必须设置退出条件。一开始循环条件设置为：在`PGROUNDUP(fp) == bottom_of_stack`进行循环，来确保fp所在的页是当前栈的页，但是这样设置会多打印出最后一个栈帧的最后一个无效的返回地址。如下图：

   ![image-20230728221212332](assets/image-20230728221212332.png)

   利用`addr2line -e kernel/kernel`命令查看地址在源代码文件中的行号：

   ![image-20230728221259536](assets/image-20230728221259536.png)

   可知最后一个地址是无效的。为了解决这个问题，在循环条件中增加`fp<botton_of_stack`的条件，确保在达到栈底之前退出。

4. ####实验心得：

   实现了系统的回溯功能，便于后续实验的调试，也对函数调用栈的结构有了了解。

### Alarm (hard)

1. ####实验目的：

   向 xv6 添加一项功能，在进程使用 CPU 时间时定期发出警报。添加系统调用`sigaarm(interval, handler)`，如果应用程序调用形式为：`sigalarm(n, fn)`，则在 程序消耗的 每n个CPU 时间后，内核调用应用程序函数fn。当fn返回时，应用程序从中断处恢复。如果应用程序调用`sigalarm(0, 0)`，内核应停止生成定期警报调用。

2. ####实验步骤：

   ####test0

   1. 将`user/alarmtest.c`添加到makefile中，以便后续运行测试。

   2. 向`user/user.h`中加入需要实现的两个函数的声明：`int sigalarm(intticks, void (*handler)()); int sigreturn(void);`

   3. 更改`user/usys.pl、kernel/syscall.h、kernel/syscall.c`文件的相关内容，加入 sigalarm 和 sigreturn 系统调用，使`alarmtest`可以调用。

   4. 在`kernel/sysproc.c`中实现sigalarm 和 sigreturn 系统调用。先将sigreturn()设置为只返回0。

   5. 实现sigalarm()函数。在`kernel/proc.h`中的proc结构体中加入存储警报间隔、指向处理函数的指针，并加入。

      ![image-20230730002924730](assets/image-20230730002924730.png)

   6. 编写sigalarm()函数，函数具体实现与部分注释如下图所示：

      ![image-20230730001220783](assets/image-20230730001220783.png)

   7. 修改`kernel/trap.c`中的usertrap，在下图所示位置加入，tita自增记录进程被调度的次数，当p->tita的值等于p->ticks时，说明进程的警报间隔到期，此时将控制权交给定时器中断处理程序p->handler。

      ![image-20230730002234814](assets/image-20230730002234814.png)

   8. 运行测试程序：

      ![image-20230730002721051](assets/image-20230730002721051.png)

   ####test1 & test2

   1. 确保寄存器内容恢复到中断时所保存的值，以便用户程序在报警后可以不受干扰地继续运行，于是在proc结构体中加入缓存trapframe的字段，并在`kernel/proc.c`的allocproc进程初始化和freeproc进程释放时释放这个变量，参考trapframe的分配、释放方式。

      ![image-20230730003135999](assets/image-20230730003135999.png)

      ![image-20230730003438074](assets/image-20230730003438074.png)

      ![image-20230730003449872](assets/image-20230730003449872.png)

   2. 再次修改`kernel/trap.c`中的usertrap，在test0的基础上修改为当CPU时钟中断次数到达阈值，则缓存trapframe并设置calling为1和trapframe的epc以调用handler。注意用到了calling变量来记录当前handler函数是否在调用中，如果还在调用中就不需要重复调用。

      ![image-20230730003611751](assets/image-20230730003611751.png)

   3. 在`kernel/sysproc.c`中实现sigreturn()，用于恢复缓存下来的trapframe。

      ![image-20230730003935063](assets/image-20230730003935063.png)

   4. 运行测试程序alarmtest：

      ![image-20230730004235166](assets/image-20230730004235166.png)

   5. 运行测试程序usertests(截图太长，只放入了结尾部分):

      ![image-20230730010637747](assets/image-20230730010637747.png)

3. ####实验中遇到的问题与解决方法：

   关于如何在usertrap中触发定时器中断：注意到在test0的文档中给出的在user.h中有关sigalarm()声明中有handle参数，它是一个函数指针。当用户进程调用系统调用sigalarm()设置定时器后，内核就将用户进程的信号处理函数的地址保存在进程的结构体中的handler字段中。在用户进程运行时，如果进程使用了alarm()设置了定时器，当定时器到期时，就会触发一个定时器中断，中断处理程序会调用usertrap()函数。在usertrap()函数中，如果which_dev等于2，说明当前中断是来自时钟设备的，此时需要根据进程设置的时间片和已经运行的时间，判断是否需要触发信号处理函数。如果需要触发信号处理函数，就将程序计数器epc设置为进程信号处理函数的地址，从而跳转到信号处理函数开始执行。

4. ####实验心得：

   对程序内核存储寄存器状态、程序计数器等信息用的结构体，以及如何统筹修改在内核的各部分以实现完整的系统调用功能有了更深了解。

## Lab: Copy-on-Write Fork for xv6

### Implement copy-on write(hard)

1. ####实验目的：

   在 xv6 内核中实现写时复制 fork。

   xv6 中的 fork() 系统调用将父进程的所有用户空间内存复制到子进程中。如果父级很大，复制可能需要很长时间。更糟糕的是，工作常常被浪费掉。例如，子进程中的 fork() 后跟 exec() 将导致子进程丢弃复制的内存，可能不会使用其中的大部分内存。另一方面，如果父级和子级都使用一个页面，并且一个或两个都写入该页面，则确实需要一个副本。

   写时复制 (COW) fork() 的目标是推迟为子级分配和复制物理内存页，直到实际需要副本（如果有）。

   COW fork() 只为子进程创建一个页表，用户内存的 PTE 指向父进程的物理页。COW fork() 将父级和子级中的所有用户 PTE 标记为不可写。当任一进程尝试写入其中一个 COW 页时，CPU 将强制发生页错误。内核页面错误处理程序检测到这种情况，为错误进程分配物理内存页面，将原始页面复制到新页面，并修改错误进程中的相关 PTE 以引用新页面，这次使用PTE 标记为可写。当页面错误处理程序返回时，用户进程将能够写入其页面副本。

   COW fork() 使得释放实现用户内存的物理页变得有点棘手。给定的物理页可能被多个进程的页表引用，并且仅当最后一个引用消失时才应释放。

2. ####实验步骤：

   1. 先在`kernel/riscv.h`的末尾加一个标准位，选取PTE中的保留位定义标记一个页面是否为COW Fork页面的标志位，如图所示。

      ![image-20230730024622735](assets/image-20230730024622735.png)

   2. 修改`kernel/vm.c`中的 uvmcopy() 以将父级的物理页面映射到子级，而不是分配新页面。清除子级和父级 PTE 中的 `PTE_W `。修改如下部分：

      ![image-20230730032059426](assets/image-20230730032059426.png)

   3. 修改`kernel/kalloc.c`

      1. 基本思想：确保每个物理页在最后一个 PTE 引用消失时被释放——但不是在此之前。实现此目的的一个好方法是为每个物理页保留引用该页的用户页表数量的“引用计数”(pa)。kalloc()分配页面时，将页面的引用计数设置为 1 。当 fork 导致子进程共享页面时增加页面的引用计数，并在每次任何进程从其页表中删除页面时减少页面的计数。 kfree()仅当其引用计数为零时才应将页面放回空闲列表，否则只是引用数-1。将这些计数保存在固定大小的整数数组中。

      2. 加入增减引用数的函数以及存储计数的数组，并在defs.h中加入声明以便在其他文件中调用：

         ![image-20230730032820758](assets/image-20230730032820758.png)

      3. 修改kfree():![image-20230730031719332](assets/image-20230730031719332.png)

      4. 修改kalloc():![image-20230730031834605](assets/image-20230730031834605.png)

   4. 修改`kernel/trap.c`中的usertrap()以识别页面错误。当 COW 页上发生页错误时，使用 kalloc() 分配新页，将旧页复制到新页，并将新页安装到设置了PTE_W的 PTE 中 。

      **识别页面错误：**先获取故障地址所对应的页表项pte，并判断页面故障的原因是否是由于写保护（scause为13或15，并且页面标志中包含PTE_C标志）。如果是，则说明该页面是COW页面，需要分配新的物理页面。将原物理页面中的数据复制到新页面中，然后更新页表项pte，使其指向新的物理页面，并设置页面标志为可写。

      ![image-20230730032713467](assets/image-20230730032713467.png)

   5. 修改 copyout() 以在遇到 COW 页面时使用与页面错误相同的方案。

      **识别页面错误：**与usertrap类似。先获取目标虚拟地址所对应的页表项pte，并判断页面故障的原因是否是由于写保护（页面标志中包含PTE_C标志）。如果是，则说明该页面是COW页面，需要分配新的物理页面，并将原物理页面中的数据复制到新页面中，然后更新页表项pte，使其指向新的物理页面，并设置页面标志为可写。

      ![image-20230730033107581](assets/image-20230730033107581.png)

   6. 运行测试程序：![image-20230730033146700](assets/image-20230730033146700.png)

3. ####实验中遇到的问题与解决方法：

   在usertrap以及copyout中如何识别页面错误。具体解决方法已包含在实验步骤中。

4. ####实验心得：

   在xv6中实现了COW，检查如何在kalloc等多处正确释放分配的空间。了解了如何识别页面错误，并正确处理页面错误。

## Lab: Multithreading

### Uthread: switching between threads (moderate)

1. ####实验目的：

   为用户级线程系统设计、实现上下文切换机制，制定一个计划来创建线程并保存/恢复寄存器以在线程之间切换，参考xv6真实的实现方式。

2. ####实验步骤：

   1. 在`user/uthread.c`中：给 thread 结构一个context字段用来保存相关寄存器，并加入thread结构体，如下图所示：

      ![image-20230730204451955](assets/image-20230730204451955.png)

   2. 修改thread_create()，将 stack 的地址给 sp 寄存器，告知操作系统此区域为栈：

      ![image-20230730204826318](assets/image-20230730204826318.png)

   3. 修改thread_schedule()，调用thread_switch来切换到下一个线程：

      ![image-20230730205437445](assets/image-20230730205437445.png)

   4. 在`user/uthread_switch.S`中实现thread_switch，保存被切换出的线程的寄存器，恢复被切换到的线程的寄存器，并返回到后一个线程的指令中最后离开的点，参照switch.S的实现方式。

      ![image-20230730205624389](assets/image-20230730205624389.png)

   5. 运行测试程序uthread：

      ![image-20230730202515619](assets/image-20230730202515619.png)

3. ####实验中遇到的问题与解决方法：

   暂无

4. ####实验心得：

### Using threads (moderate)

1. ####实验目的：

   使用哈希表探索线程和锁的并行编程

2. ####实验步骤：

   1. 在xv6主目录（并非虚拟机中）运行`make ph`直接编译，可以看到如下输出，当两个线程并行时发生了键值丢失：

      ![image-20230730212330296](assets/image-20230730212330296.png)

   2. 在 `notxv6/ph.c`中的`put`和`get`中插入锁定和解锁语句，以便两个线程中丢失的键数始终为 0。

      ![image-20230730214224596](assets/image-20230730214224596.png)

   3. 在main中对锁进行初始化。

      ![image-20230730214251055](assets/image-20230730214251055.png)

   4. 运行`make ph`编译，运行`./ph 1`单线程测试：

      ![image-20230730212007726](assets/image-20230730212007726.png)

   5. 运行`./ph 2`多线程测试：

      ![image-20230730212113652](assets/image-20230730212113652.png)

3. ####实验中遇到的问题与解决方法：

   1. **回答问题：向哈希表添加条目时，为什么2线程会丢失键，而1线程则不会？**

      向哈希表添加条目时，如果在未添加锁时使用了线程并行，就可能会发生并发冲突，导致键值对丢失。

      当只有一个线程时，由于其操作的是串行的，因此不会发生并发冲突，所以不会丢失键值对。但是，当有多个线程并发访问哈希表时，需要采用一些线程安全的技术，如加锁、使用无锁算法等，以确保线程安全性，避免键值对丢失。

      在并行情况下，多个线程可能同时尝试在哈希表中添加条目，而哈希表的数据结构并没有锁来保证线程安全性。如果并发线程同时尝试在哈希表中插入键相同的条目，其中一个线程的操作就可能会覆盖另一个线程的操作，导致一个键值对丢失。

   2. **可能导致密钥丢失的事件序列**

      1. 线程1执行插入操作，将键值对(key1, value1)插入哈希表中。
      2. 线程2执行插入操作，将键值对(key2, value2)插入哈希表中。
      3. 线程1执行查找操作，查找键(key2)对应的值，但由于线程2已经插入了键值对(key2, value2)，所以线程1查找失败。
      4. 线程2执行查找操作，查找键(key1)对应的值，但由于线程1插入的键值对(key1, value1)在哈希表中没有被找到，所以线程2查找失败。

4. ####实验心得：

   学会使用进程锁，通过锁的方式成功保证了线程的安全性，在多个进程并行写哈希表时避免了条目缺失。

### Barrier(moderate)

1. ####实验目的：

   实现多线程同步屏障，所有参与线程都必须等待达到一个点，直到所有其他参与线程也到达该点，才继续执行。

2. ####实验步骤：

   1. 在xv6主目录中直接编译运行barrier：

      ![image-20230730220722521](assets/image-20230730220722521.png)

   2. 在 `notxv6/barrier.c`中实现barrier()函数。具体函数与过程注释见下图。为了实现等待所有线程都达到一个点，使用了两个计数器来统计调用barrier的线程数，达到所有线程都调用barrier时才唤醒进程，否则都使其处于等待状态。 `bstate.round`记录当前回合。每次所有线程都到达屏障时， 增加bstate.round ；

      ![image-20230730221442144](assets/image-20230730221442144.png)

   3. 编译并运行测试程序：

      ![image-20230730220434870](assets/image-20230730220434870.png)

3. ####实验中遇到的问题与解决方法：

   要注意对进程锁操作的顺序。如，先获取锁，再使其阻塞，最后再释放，以免出现卡死。因为阻塞进程的前提是拥有锁，如果先释放了锁，可能会导致其他线程同时获得锁并访问bstate.nthread计数器，从而导致计数器的值不正确；也可能导致条件变量被错误地触发、或永远不会被触发，从而等待的线程无法被正确地唤醒，造成死锁。

4. ####实验心得：

   学会使用进程的等待、唤醒来实现进程间同步，并对其进行计数。

## 未解决Lab: networking (hard)

1. ####实验目的：

2. ####实验步骤：

3. ####实验中遇到的问题与解决方法：

4. ####实验心得：

## Lab: locks

### Memory allocator (moderate)

1. ####实验目的：

   修改内存块的表示，减少内存块的竞争问题。

2. ####实验步骤：

   1. 在初始状态下编译，运行kalloctest，能看到如下图所示的竞争情况：

      ![image-20230730231548212](assets/image-20230730231548212.png)

   2. 在`kernel/kalloc.c`中修改内存块的表示，考虑将原本为一大块的freelist进行拆分，给每个 cpu 分配一个freelist，来降低竞争。（NCPU的定义在`kernel/param.h`中）

      ![image-20230730233602714](assets/image-20230730233602714.png)

   3. 因为内存块更改，所以也需要修改初始化kinit()，原本是一个大块，现在要空闲内存分别分配。

      ![image-20230730233730135](assets/image-20230730233730135.png)

   4. 修改kfree()，注意获取CPU的ID时关闭中断，避免获取ID的过程中出现竞争。![image-20230730234326252](assets/image-20230730234326252.png)

   5. 修改kalloc()，如果当前CPU有空闲内存块，就直接返回；如果没有，则依次遍历其他CPU的空闲内存块链表，从中寻找可用内存块。当找到可用内存块时，将其从对应的空闲内存块链表中取出，更新链表头指针。

      ![image-20230730235510097](assets/image-20230730235510097.png)

   6. 运行测试程序：

      ![image-20230731000341835](assets/image-20230731000341835.png)

3. ####实验中遇到的问题与解决方法：

   注意在释放内存块时，获取CPU ID时关闭中断。每个CPU都有自己的内存池和空闲内存块链表，在释放内存块时需要根据当前CPU的ID来选择对应的内存池和空闲内存块链表。在多CPU系统中，如果多个CPU同时调用`cpuid()`函数，可能会出现竞争条件，从而导致获取到错误的CPU ID。因此需要先关闭中断，获取完成后再开启。

4. ####实验心得：

   减少了内存块竞争的问题，提高了CPU的性能，也可以避免后续实验中死锁问题和其他竞争条件的出现，提高系统的可靠性。

### Buffer cache (hard)

1. ####实验目的：

   解决cache缓存竞争问题。如果多个进程密集使用文件系统，它们可能会争夺bcache.lock，修改块缓存，以便运行bcachetest时bcache中所有锁的获取循环迭代次数接近于零。理想情况下，块缓存中涉及的所有锁的计数总和应为零，但总和小于500也可以。

2. ####实验步骤：

   1. 在初始状态下编译，运行bcachetest，如下图所示。这里不仅需要所有 bucket 的小锁，还需要一个大的锁防止死锁，且不能像任务一那样直接使用 bcache 数组，这会改变 buf 的大小。

      ![image-20230731104919127](assets/image-20230731104919127.png)

   2. 为`kernel/buf.h`添加lastuse字段，便于保存该缓存块上一次被访问的时间戳，使用LRU机制。` uint lastuse;`

   3. 在`kernel/param.h`中添加桶数量的宏定义，。`#define NBUCKET  13`。使用固定数量的桶并且不动态调整哈希表的大小，使用素数的桶（例如，13）来减少散列冲突的可能性。

   4. 修改`kernel/bio.c`。先修改数据结构，并声明外部变量ticks，使用上次使用的时间来代替时间戳缓冲区。

      ![image-20230731140147628](assets/image-20230731140147628.png)

   5. 在开头添加一个简单的哈希函数，用于后续将给定的块号（blockno）映射到一个哈希桶的索引。大小已在param.h中定义。

      ![image-20230731134227341](assets/image-20230731134227341.png)

   6. 修改初始化块缓存的函数binit()，修改为先初始化大锁来保护整个缓存， 再初始化各个桶的小锁。

      ![image-20230731135555180](assets/image-20230731135555180.png)

   7. 修改释放一个缓存块的函数brelse()。在遇到空闲块的时候，改为直接设置它的使用时间（lastuse字段）为系统时间，来代替原有的时间缓冲区方式。

      ![image-20230731140923877](assets/image-20230731140923877.png)

   8. 修改增加、减少引用数的函数bpin()和bunpin()，根据数据结构更改加锁方式。

      ![image-20230731141029936](assets/image-20230731141029936.png)

   9. 更改获取块的函数bget()，将查找情况分类讨论。以下按查找情况放出部分代码。

      1. 如果命中，则将其引用计数加一，释放该桶的锁，并获取该缓存块的锁，然后返回该缓存块的指针。

         ![image-20230731142313283](assets/image-20230731142313283.png)

      2. 如果不命中，则释放当前桶的锁，释放锁后又可能会有缓存，先遍历目前的块，看是否命中。

         ![image-20230731142402565](assets/image-20230731142402565.png)

      3. 如果不命中，则寻找当前桶对应的LRU的空闲块，使用ticks的方式

         ![image-20230731142431108](assets/image-20230731142431108.png)

      4. 如果不命中，当前桶中没有，就向其他桶中寻找块，注意过程中的加锁和释放，以保证缓存的安全

         ![image-20230731142715586](assets/image-20230731142715586.png)

   10. 运行测试程序：![image-20230731112343337](assets/image-20230731112343337.png)

3. ####实验中遇到的问题与解决方法：

   1. 根据文档提示，使用每个桶都有一个锁的哈希表在缓存中查找块号，所以需要给每个桶增加一个大锁，每个块也应有一个锁。在一开始的调试中忽略了文档的这一点，导致运行出现问题，后修改桶的结构，加入了大锁。在后续寻找块的时候也要先获取大锁。
   2. 在释放当前桶的锁后，要再次遍历桶中的块查看是否命中。因为释放以后其他线程可能会修改当前桶中的缓存块，从而导致当前线程再次查找时可能会发现新的缓存块并命中。为了避免遗漏，就采取在释放锁以后再次查找、如果能命中直接返回、不命中才去找当前桶对应的LRU空闲块的方式。

4. ####实验心得：

   对锁的机制有了更为全面的了解，也学习了寻找cache块命中、不命中等多种情况下如何进行相关处理，学会使用锁来解决cache缓存竞争问题。

## Lab: file system

### Large files (moderate)

1. ####实验目的：

   增加 xv6 文件的最大大小。目前 xv6 文件限制为 268 个块或 268*BSIZE 字节（xv6 中 BSIZE 为 1024）。

2. ####实验步骤：

   1. 修改 `kernel/fs.h` 中直接块号的宏定义 ，NDIRECT从原来的12改成11。`#define NDIRECT 11`
   2. 根据文档提示修改inode相关结构体的块号数组，而不能更改inode大小。将inode结构体和addrs字段大小修改为NDIRECT+2。因为实际 inode 的块号总数没有改变, 但 NDIRECT 减少了 1。需要修改的有两处：
      1. `kernel/fs.h`中的磁盘 inode 结构体（struct dinode的 addrs 字段）
      2. `kernel/file.h`中的内存 inode 结构体（struct inode 的 addrs 字段）。
   3. 运行测试程序：![image-20230731161932135](assets/image-20230731161932135.png)

3. ####实验中遇到的问题与解决方法：

4. ####实验心得：

### Symbolic links (moderate)

1. ####实验目的：

2. ####实验步骤：

   1. a
   2. 在`kernel/param.h`中添加宏定义。`#define NSYMLINK  8`
   3. 运行测试程序：![image-20230731164557949](assets/image-20230731164557949.png)

3. ####实验中遇到的问题与解决方法：

4. ####实验心得：

## Lab: mmap (hard)

1. ####实验目的：

2. ####实验步骤：

3. ####实验中遇到的问题与解决方法：

4. ####实验心得：